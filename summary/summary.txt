На Хабре уже есть довольно богатый материал на тему деревьев отрезков.
Я решил реализовать эту структуру средствами Erlang. Хочу поделиться некоторыми соображениями,
которыми я руководствовался при реализации

Начнём с такой простой подзадачки: реализуем функцию попарного объединения соседних элементов списка, например
список [A, B, C, D, E, F] должен превратится в [{A,B}, {C,D}, {E,F}].

%% точка входа
pairs(List) ->
        pairs(List, []).
%% все пары созданы
pairs([], Acc) ->
        lists:reverse(Acc);
%% если в списке только один элемент
pairs([S], Acc) ->
        pairs([], [S | Acc]);
%% берём 2 первых элемента списка и объединяем
pairs([A, B | T], Acc) ->
        pairs(T, [{A,B} | Acc]).

А что если результирующий список опять подать на вход в функцию pairs?
[{A,B}, {C,D}, {E,F}] превратится в [{{A,B},{C,D}}, {E,F}]
И повторять эту процедуру пока результирующий список содержит больше одного элемента:
[{{A,B},{C,D}}, {E,F}] превратится в [{{{A,B},{C,D}},{E,F}}]
Если внимательно посмотреть - полученный таким образом единственный элемент результирующего списка есть 
бинароное дерево.

Таки образом, функцию pairs очень легко превратить в функцию построения бинарного дерева: 

tree(List) ->
        tree(List, []).
%% если результирующий список содержит больше одного элемента - значит нужно продолжить построение дерева
tree([], Acc) when length(Acc) > 1 ->
        tree(lists:reverse(Acc), []);
%% если в результирующем списке один элемент - значит дерево построено
tree([], [Tree]) ->
        Tree;
tree([S], Acc) ->
        tree([], [S | Acc]);
tree([A, B | T], Acc) ->
        tree(T, [{A,B} | Acc]).

Итак, дерево уже умеем построить. Самое время подумать о том, что будут представлять из себя узлы дерева.

Момент, о котором я не упомянул в начале - мы будем создавать обобщённую структуру данных. Таким образом,
пользователь может сам определить операцию(операции) на дереве отрезков.

Каждый узел будет содержат левое и правое поддерево, интервал который является объединением интервалов левого и правого поддеревьев,
а также значение операции на даном интервале.

Пора использовать записи

Определим интервал:
-record(interval, {left, right}).
%% нам также понадобится константа для пустого интервала
-define(EMPTY_INTERVAL, null).
