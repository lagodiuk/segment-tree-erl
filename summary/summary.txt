На Хабре уже есть довольно богатый материал на тему деревьев отрезков.
Я решил реализовать эту структуру средствами Erlang. Хочу поделиться некоторыми соображениями,
которыми я руководствовался при реализации

Мы будем создавать обобщённую структуру данных. Таким образом, чтоб
пользователь мог сам определить операцию/операции на дереве отрезков.

Начнём с такой простой подзадачки: реализуем функцию попарного объединения соседних элементов списка, например
список [A, B, C, D, E, F] должен превратится в [{A,B}, {C,D}, {E,F}].

%% точка входа
pairs(List) ->
        pairs(List, []).
%% если все пары созданы
pairs([], Acc) ->
        lists:reverse(Acc);
%% если в списке только один элемент
pairs([S], Acc) ->
        pairs([], [S | Acc]);
%% в остальных случаях - берём 2 первых элемента списка и объединяем
pairs([A, B | T], Acc) ->
        pairs(T, [{A,B} | Acc]).

А что если результирующий список опять подать на вход в функцию pairs?
[{A,B}, {C,D}, {E,F}] превратится в [{{A,B},{C,D}}, {E,F}]
И повторять эту процедуру пока не получим список из одного элемента:
[{{A,B},{C,D}}, {E,F}] превратится в [{{{A,B},{C,D}},{E,F}}]
Gолученный таким образом единственный элемент результирующего списка является бинарным деревом.

Таким образом, функцию pairs очень легко превратить в функцию построения бинарного дерева: 

tree(List) ->
        tree(List, []).
%% если результирующий список содержит больше одного элемента - значит нужно продолжить построение дерева
tree([], Acc) when length(Acc) > 1 ->
        tree(lists:reverse(Acc), []);
%% если в результирующем списке один элемент - значит дерево построено
tree([], [Tree]) ->
        Tree;
tree([S], Acc) ->
        tree([], [S | Acc]);
tree([A, B | T], Acc) ->
        tree(T, [{A,B} | Acc]).

Итак, дерево уже умеем построить. Самое время подумать о том, что будут представлять из себя узлы дерева.

Каждый узел будет содержать: левое и правое поддерево, интервал который покрывается узелом (является объединением интервалов левого и 
правого поддеревьев), а также значение операции на даном интервале. Всего - четыре поля, думаю пора использовать записи

1) Интервал:
-record(interval, {left, right}).
%% также понадобится константа для пустого интервала
-define(EMPTY_INTERVAL, null).

2) Узел:
-record(node, {left, right, val, interval}).
%% также понадобится константа для отсутствующего поддерева
-define(EMPTY_CHILD, null).

Чтоб не создавать лищних сущностей, лист дерева отрезков можно определить в терминах описанных выше записей.
Листом будем называть узел, у интервала которого left и right равны, 
он также должен хранить сответствующий элемент входной последовательности (пригодится для операции update) - 


Хоть, как по мне, синтаксис записей в Эрланге довольно неуклюжый, но всё же их использование помогает в понимании кода.
